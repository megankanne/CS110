1.
a. 
My system enables workers to process commands for different branches at the same time. This is because I lock the branch lock only if I am doing something that will affect the branch balance (aka. deposit/withdraw or a transfer between branches).  The branch is also not locked if the transfer occurring is within the same branch because, again, it doesn't affect the branch balance. Therefore, two intra-branch operations can occur concurrently (so long as they are accessing different accounts). Both of my bank balance and branch balance functions are serializable because they use the lock all of the branches necessary for the operation before continuing. In the bank balance case this is each branch in the bank. In the branch balance case it is the branch being queried. Reporting of transfers is also now concurrent because the reports are stored in their own data structure for each thread which is aggregated at nightly reporting time. Interactions with individual accounts can no longer proceed concurrently. Each time an action on a account is called the account(s) involved are locked. Also, balance requests are atomic and, as mentioned above, are serializable but can't occur concurrently. As described above, actions that effect branch balance are atomic and no longer concurrent.        

b.
One way to decrease the probability of deadlocks on a high-magnitude system would be to disallow transfers between branches. In this case, all transfers would be between accounts of the same branch preventing the need to edit the branch (and hence bank) balance. Therefore, we would not need to lock branches when executing transfers. 
In my program, the main way I tried to avoid deadlocks was insuring that locks were only initialized once (this was a huge bug for me) as well as insuring that locks were only locked in increasing order by account number. This second condition avoided loops in the locking graph.   

2.
a.
During the check if (account->balance < amount) the man has enough money in his account for the withdrawal of amount say $100,000. Then a second thread at that moment removes all $100,000 from his account. Now his account has $0 but this original thread still hasn't executed the account->balance -= amount. When this thread does so, his account balance will circle around (because it is unsigned) to the highest integer value of it's type. So the man is very rich!   

b.
Yes, the wraparound would result in a smaller number but the man would still be rich!

4.
I developed on corn.

5.
No I didn't complete any EC.